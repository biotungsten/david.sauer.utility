normalized.data.aggregated[,1] %in% c("catechol")
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, "resorcinol")
library(stringr)
library(ggplot2)
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, c("resorcinol"))
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, c("hydrochinon"))
normalized.catechol.data <- filter.data.by.substances(normalized.data, c("catechol"))
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, c("resorcinol"))
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, c("hydrochinon"))
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
m.resorcinol.norm <- fit.hill.model(normalized.resorcinol.data, response.variable.name = "ratio")
m.hydrochinon.norm <- fit.hill.model(normalized.hydrochinon.data, response.variable.name = "ratio")
sample.data = data.frame(concentration = seq(0,100,0.1))
predict(m.catechol.norm, sample.data)
library(stringr)
library(ggplot2)
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, c("resorcinol"))
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, c("hydrochinon"))
normalized.catechol.data <- filter.data.by.substances(normalized.data, c("catechol"))
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, c("resorcinol"))
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, c("hydrochinon"))
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
m.resorcinol.norm <- fit.hill.model(normalized.resorcinol.data, response.variable.name = "ratio")
m.hydrochinon.norm <- fit.hill.model(normalized.hydrochinon.data, response.variable.name = "ratio")
sample.data = data.frame(concentration = seq(0,100,0.1))
predict(m.catechol.norm, sample.data)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data, catechol.pred)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, pch="+")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, pch="l")
plot(sample.data$concentration, catechol.pred, pch="c")
plot(sample.data$concentration, catechol.pred, pch="n")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Catechol")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Resorcinol")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Hydrochinon")
install.packages("devtools")
install.packages("roxygen2")
library(devtools)
library(roxygen2)
setwd(" ~/Dev/HerbicideDev/")
setwd(" ~/Dev/HerbicideDev/")
setwd("~/Dev/HerbicideDev/")
create("personal_package")
create("david.sauer.utility")
ls
setwd("./david.sauer.utility/")
document()
document()
plot.dose.response.appl2 <- function(aggregated.data, model.data, predicted.data, substance.name, x.upper.lim = 100) {
plot.dose.response(aggregated.data = aggregated.data, model.data = model.data, predicted.data = predicted.data, title = paste(substance.name, "+ 0.1% (v/v) Tween20 nach 7 Tagen"), x.upper.lim = x.upper.lim, xlab = "Konzentration (mM)", ylab = "normalisiertes relatives Wachstum")
}
plot.dose.response <- function(aggregated.data, model.data, predicted.data, title, x.upper.lim, xlab, ylab) {
remove.ctrl <- function(df) {
return(df[df$substance != "control", ])
}
ec50 <- coefficients(model.data)[1]
n <- coefficients(model.data)[2]
ec50.confint.upper <- round(confint(model.data)[1,][2], 2)
ec50.confint.lower <- round(confint(model.data)[1,][1], 2)
n.confint.upper <- round(confint(model.data)[2,][2], 2)
n.confint.lower <- round(confint(model.data)[2,][1], 2)
p <- ggplot(data = predicted.data,
mapping = aes(x = concentration,
y = ratio.mean)) +
scale_x_log10(limits = c(NA,x.upper.lim),
expand = c(0,0)) +
scale_y_continuous(limits = c(0, NA),
expand = c(0,0)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
plot.margin = unit(c(1,1,1,1),"cm")) +
geom_line() +
geom_errorbar(data = remove.ctrl(aggregated.data),
mapping = aes(ymin = ratio.mean-ratio.sd,
ymax = ratio.mean+ratio.sd),
color = "turquoise4",
alpha = 0.7,
size = .25) +
geom_point(data = remove.ctrl(aggregated.data),
mapping = aes(x = concentration,
y = ratio.mean),
shape = "+",
size = 5,
stroke = .15,
color = "turquoise4") +
labs(x = xlab,
y = ylab,
title = title,
subtitle = paste("EC50 (95%): ", ec50.confint.lower, " - ", ec50.confint.upper, ", n (95%): ", n.confint.lower, " - ", n.confint.upper, sep="")) +
geom_segment(mapping = aes(x = ec50,
y = 0,
xend = ec50,
yend = 0.5),
linetype = "dotted",
size = .25) +
coord_cartesian(clip = "off")
ggsave(paste(substance.name, "plot", format(Sys.time(), "%d-%m-%Y.jpg"), sep="_"), dpi = "retina", device = "jpg")
}
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
library(stringr)
library(ggplot2)
library(ggtext)
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, c("resorcinol"))
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, c("hydrochinon"))
normalized.catechol.data <- filter.data.by.substances(normalized.data, c("catechol"))
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, c("resorcinol"))
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, c("hydrochinon"))
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
m.resorcinol.norm <- fit.hill.model(normalized.resorcinol.data, response.variable.name = "ratio")
m.hydrochinon.norm <- fit.hill.model(normalized.hydrochinon.data, response.variable.name = "ratio")
sample.data <- data.frame(concentration = seq(0,500,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Catechol")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Resorcinol")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Hydrochinon")
catechol.pred.df <- data.frame(concentration = sample.data$concentration, ratio.mean = catechol.pred)
resorcinol.pred.df <- data.frame(concentration = sample.data$concentration, ratio.mean = resorcinol.pred)
hydrochinon.pred.df <- data.frame(concentration = sample.data$concentration, ratio.mean = hydrochinon.pred)
setwd("/Users/David_Sauer/Documents/Documentation/Experiments/Sep2021-Appl2/figures")
plot.dose.response.appl2(normalized.data.aggregated.catechol, m.catechol.norm, catechol.pred.df, "Catechol", x.upper.lim = 110)
plot.dose.response.appl2 <- function(aggregated.data, model.data, predicted.data, substance.name, x.upper.lim = 100) {
plot.dose.response(aggregated.data = aggregated.data, model.data = model.data, predicted.data = predicted.data, title = paste(substance.name, "+ 0.1% (v/v) Tween20 nach 7 Tagen"), x.upper.lim = x.upper.lim, xlab = "Konzentration (mM)", ylab = "normalisiertes relatives Wachstum", filename = substance.name)
}
plot.dose.response <- function(aggregated.data, model.data, predicted.data, title, x.upper.lim, xlab, ylab, filename) {
remove.ctrl <- function(df) {
return(df[df$substance != "control", ])
}
ec50 <- coefficients(model.data)[1]
n <- coefficients(model.data)[2]
ec50.confint.upper <- round(confint(model.data)[1,][2], 2)
ec50.confint.lower <- round(confint(model.data)[1,][1], 2)
n.confint.upper <- round(confint(model.data)[2,][2], 2)
n.confint.lower <- round(confint(model.data)[2,][1], 2)
p <- ggplot(data = predicted.data,
mapping = aes(x = concentration,
y = ratio.mean)) +
scale_x_log10(limits = c(NA,x.upper.lim),
expand = c(0,0)) +
scale_y_continuous(limits = c(0, NA),
expand = c(0,0)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
plot.margin = unit(c(1,1,1,1),"cm")) +
geom_line() +
geom_errorbar(data = remove.ctrl(aggregated.data),
mapping = aes(ymin = ratio.mean-ratio.sd,
ymax = ratio.mean+ratio.sd),
color = "turquoise4",
alpha = 0.7,
size = .25) +
geom_point(data = remove.ctrl(aggregated.data),
mapping = aes(x = concentration,
y = ratio.mean),
shape = "+",
size = 5,
stroke = .15,
color = "turquoise4") +
labs(x = xlab,
y = ylab,
title = title,
subtitle = paste("EC50 (95%): ", ec50.confint.lower, " - ", ec50.confint.upper, ", n (95%): ", n.confint.lower, " - ", n.confint.upper, sep="")) +
geom_segment(mapping = aes(x = ec50,
y = 0,
xend = ec50,
yend = 0.5),
linetype = "dotted",
size = .25) +
coord_cartesian(clip = "off")
ggsave(paste(filename, "plot", format(Sys.time(), "%d-%m-%Y.jpg"), sep="_"), dpi = "retina", device = "jpg")
}
setwd("/Users/David_Sauer/Documents/Documentation/Experiments/Sep2021-Appl2/figures")
plot.dose.response.appl2(normalized.data.aggregated.catechol, m.catechol.norm, catechol.pred.df, "Catechol", x.upper.lim = 110)
plot.dose.response.appl2(normalized.data.aggregated.resorcinol, m.resorcinol.norm, resorcinol.pred.df, "Resorcinol", x.upper.lim = 130)
plot.dose.response.appl2(normalized.data.aggregated.hydrochinon, m.hydrochinon.norm, hydrochinon.pred.df, "Hydrochinon", x.upper.lim = 150)
library(devtools)
document()
load_all()
getwd()
githun_pat()
github_pat()
github_pat()
