}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, "resorcinol")
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, "hydrochinon")
normalized.catechol.data <- filter.data.by.substances(normalized.data, "catechol")
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, "resorcinol")
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, "hydrochinon")
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[substance.colindex] %in% substance.names, ]
print(data[substance.colindex] %in% substance.names)
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[substance.colindex] %in% substance.names, ]
print(substance.names)
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[substance.colindex] %in% substance.names, ]
print(substance.colindex)
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[substance.colindex] %in% substance.names, ]
print(data[substance.colindex])
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated$substance %in% c("catechol")
normalized.data.aggregated$substance %in% c("catechol", "control")
normalized.data.aggregated[1] %in% c("catechol", "control")
normalized.data.aggregated[1,] %in% c("catechol", "control")
normalized.data.aggregated[1]
normalized.data.aggregated$concentration
normalized.data.aggregated$substance
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[c(data[substance.colindex]) %in% substance.names, ]
print(data[substance.colindex] %in% c("catechol"))
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[c(data[substance.colindex]) %in% substance.names, ]
print(c(data[substance.colindex]) %in% substance.names)
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
c(normalized.data.aggregated[1]) %in% c("catechol")
normalized.data.aggregated$substance %in% c("catechol")
normalized.data.aggregated[1] %in% c("catechol")
normalized.data.aggregated[,1] %in% c("catechol")
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, "resorcinol")
library(stringr)
library(ggplot2)
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, c("resorcinol"))
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, c("hydrochinon"))
normalized.catechol.data <- filter.data.by.substances(normalized.data, c("catechol"))
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, c("resorcinol"))
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, c("hydrochinon"))
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
m.resorcinol.norm <- fit.hill.model(normalized.resorcinol.data, response.variable.name = "ratio")
m.hydrochinon.norm <- fit.hill.model(normalized.hydrochinon.data, response.variable.name = "ratio")
sample.data = data.frame(concentration = seq(0,100,0.1))
predict(m.catechol.norm, sample.data)
library(stringr)
library(ggplot2)
#Appl2 specific
#' Converts a label of the format X...-Y where X is the substance abbreviation and Y is the concentration. CTRL is treated as abbreviation for control.
appl2.label.as.vector <- function(label){
if(str_starts(label, "CTRL")){
return(c("control", 0))
}
substance.abbreviation <- str_sub(label, 1, 1)
substance.name <- switch(substance.abbreviation,
C = "catechol",
R = "resorcinol",
H = "hydrochinon")
concentration <- as.numeric(str_split(label, "-")[[1]][2])
return(c(substance.name, concentration))
}
#' TBD
filter.data.by.substances <- function(data, substance.names, substance.colname = "substance", concentration.colname = "concentration", include.control = TRUE, concentrations.factors = TRUE) {
substance.colindex = grep(substance.colname, colnames(data))
concentration.colindex = grep(concentration.colname, colnames(data))
if (include.control) {
substance.names <- c("control", substance.names)
}
filtered.data <- data[data[,substance.colindex] %in% substance.names, ]
if (concentrations.factors) {
filtered.data[concentration.colindex] <- as.numeric.factor(filtered.data[concentration.colindex])
}
return(filtered.data)
}
#' Fits a hill model using \code{nls}. The formula for the hill model is \eqn{\frac{1}{1+\frac{c}{EC_{50}^n}}.
#' @param data A data frame providing the data, to which the model will be fitted. A column with concentrations (named concentrations) is required. It should contain in the same unit the concentrations for each measurement.
#' @return A model object (nlsModel) fitted to the data provided.
fit.hill.model <- function(data, response.variable.name = "response", guesses = c(1, 1), print.summary = TRUE) {
hill.formula <- as.formula(paste(response.variable.name, "~ 1/(1+(concentration/ec50)^n)"))
model <- nls(hill.formula, data = data, start = c(ec50 = guesses[1], n = guesses[2]), lower = c(ec50 = 0, n = 0))
if (print.summary) {
print(summary(model))
}
return(model)
}
#' TBD
as.numeric.factor <- function(x) {
return(as.numeric(as.character(x[,])))
}
#' TBD
as.idx.colname <- function(data, name) {
return(grep(paste("^",name,"$", sep=""), colnames(data)))
}
#' TBD. If use.normalize.value is FALSE, certain rows out of data are selected and the mean of the values in their colname.normalize column is used as normalize.value.
#' @param data
#' @param colname.normalize The name of the column in which the data, data should be normalized are located. Further if use.normalize.value is false, this column will be used to calculate normalize.value.
#' @param colname.selection The name of the column in which the object.selection object should be matched.
#' @param object.selection The object which must be matched in the column specified by colname.selection for rows to be included in the normalize.value.
#' @param normalize.value The value which to use for normalizing. Is ignored if use.normalize.value is FALSE.
#' @param use.normalize.value A boolean to indicate whether or not the normalize.value parameter should be used.
normalize.data <- function(data, colname.normalize, colname.selection, object.selection, normalize.value = 1, use.normalize.value = FALSE) {
if (!use.normalize.value) {
normalize.data.points <- data[data[as.idx.colname(data, colname.selection)] == object.selection, ]
normalize.value <- as.numeric(apply(normalize.data.points[as.idx.colname(data, colname.normalize)], 2, mean))
}
data[as.idx.colname(data, colname.normalize)] <- apply(data, 1, function(x) {
return(as.numeric(x[as.idx.colname(data, colname.normalize)])/normalize.value)
})
return(data)
}
raw.data <- read.csv("Beobachtungen.csv", header = TRUE, sep = ",")
info.raw.data <- apply(raw.data, 1, function(x) {
return(appl2.label.as.vector(x[as.idx.colname(raw.data, "label")]))
})
raw.data <- cbind(t(data.frame(info.raw.data)), raw.data)
colnames(raw.data) <- c("substance", "concentration", "label", "X0", "X7")
rownames(raw.data) <- seq(1, dim(raw.data)[1], 1)
raw.data <- raw.data[!is.na(raw.data$substance),]
data <- raw.data
data$ratio <- data$X7/data$X0
data$X0 <- NULL
data$X7 <- NULL
normalized.data <- normalize.data(data, "ratio", "substance", "control")
normalized.data.aggregated <- aggregate(ratio ~ substance + concentration, data = normalized.data, function(x) c(mean = mean(x), sd = sd(x)))
normalized.data.aggregated <- do.call(data.frame, normalized.data.aggregated)
rownames(normalized.data.aggregated) <- seq(1, dim(normalized.data.aggregated)[1], 1)
normalized.data.aggregated.catechol <- filter.data.by.substances(normalized.data.aggregated, c("catechol"))
normalized.data.aggregated.resorcinol <- filter.data.by.substances(normalized.data.aggregated, c("resorcinol"))
normalized.data.aggregated.hydrochinon <- filter.data.by.substances(normalized.data.aggregated, c("hydrochinon"))
normalized.catechol.data <- filter.data.by.substances(normalized.data, c("catechol"))
normalized.resorcinol.data <- filter.data.by.substances(normalized.data, c("resorcinol"))
normalized.hydrochinon.data <- filter.data.by.substances(normalized.data, c("hydrochinon"))
m.catechol.norm <- fit.hill.model(normalized.catechol.data, response.variable.name = "ratio")
m.resorcinol.norm <- fit.hill.model(normalized.resorcinol.data, response.variable.name = "ratio")
m.hydrochinon.norm <- fit.hill.model(normalized.hydrochinon.data, response.variable.name = "ratio")
sample.data = data.frame(concentration = seq(0,100,0.1))
predict(m.catechol.norm, sample.data)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data, catechol.pred)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred)
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, pch="+")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, pch="l")
plot(sample.data$concentration, catechol.pred, pch="c")
plot(sample.data$concentration, catechol.pred, pch="n")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x")
sample.data <- data.frame(concentration = seq(0,100,0.1))
catechol.pred <- predict(m.catechol.norm, sample.data)
resorcinol.pred <- predict(m.resorcinol.norm, sample.data)
hydrochinon.pred <- predict(m.hydrochinon.norm, sample.data)
plot(sample.data$concentration, catechol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Catechol")
plot(sample.data$concentration, resorcinol.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Resorcinol")
plot(sample.data$concentration, hydrochinon.pred, type="l", log="x", xlab="Konzentration (µM)", ylab="normalisiertes relatives Wachstum", main="Hydrochinon")
install.packages("devtools")
install.packages("roxygen2")
library(devtools)
library(roxygen2)
setwd(" ~/Dev/HerbicideDev/")
setwd(" ~/Dev/HerbicideDev/")
setwd("~/Dev/HerbicideDev/")
create("personal_package")
create("david.sauer.utility")
ls
setwd("./david.sauer.utility/")
document()
document()
